#  #########################    #########################               ##########################    #######################
                                                          # Read Me #
#  #########################    #########################               ##########################    #######################

""""User Manual for the Motor Unit (in MU-file), Surface Electromyography (in sEMG-file), and SaveData (in SD-file) Classes:
These three clases make the program for synthetic surface electromyography data.

Motor Unit class:

  The Motor Unit (MU) class represents a single motor unit. It has the following methods:
  Methods:
    get_tripole_amplitude(): Returns the amplitude of the tripole signal generated by the calculated current distribution.
    plot_current_distribution_action_potential(): Plots the current distribution and action potential, computed in get_tripole_amplitude().
    get_tripole_distance(): Returns the distance between the tripole of the current distribution.
    simulate_fibre_action_potential(): Simulates the action potential of a single muscle fibre in the motor unit.
    plot_fibre_action_potential(): Plots the single fibre action potential for all electrodes, computed in simulate_fibre_action_potential().
    simulate_motor_unit(): Simulates the action potential of the entire motor unit.
    plot_motor_unit(): Plots the action potential of the motor unit for all electrodes, computed in simulate_motor_unit().

  The MU class also has a number of attributes that can be used to configure the simulation, such as:
  Attributes:
    For get_tripole_amplitude:
      A: Constant to fit the amplitude of the tripole (V).
      B: Resting membrane potential amplitude (V).
      C: Muscle fibre proportionality constant.
      plot_length: Length for plotting the action potential and current distribution expressed in mm (20 mm).
      scaling_factor: A scaling factor expressed in mm^-1, lambda (λ).

    For simulate_fibre_action_potential: 
      fibre_length: Length of fibre (mm).
      neuromuscular_junction: Position of NMJ along the length of the fibre (mm).
      conduction_velocity: Conduction velocity along the muscle fibre (m/s). 
      electrode_shift: Position of center of electrode array along the length of the fibre (mm). [electrode_shift = neuromuscular_junction means the array sits centered above NMJ.]
      number_of_electrodes_z: Number of elecrodes in the array, in the direction of the fibre.
      number_of_electrodes_x: Number of electrodes in the array across the fiber.
      inter_electrode_spacing: Distance between electrodes in the array (mm).
      radial_conductivity: Conductivity in radial direction, across the fibre (m/s).
      ratio_axial_radial_conductivity: Ratio between axial and radial conductivity, (fibre direction conductivity / radial conductivity)
      fibre_depth: Initial depth from the surface EMG down to the fibre (mm).

    For simulate_motor_unit:
      motor_unit_radius: Radius of the motor unit (mm).
      number_of_fibres: The number of fibres in a given motor unit.

    For plotting methods:
      y_limit_minimum: Minimum value of plot y-axis.
      y_limit_maximum: Maximum value of plot y-axis.
...

Surface Electromyography Class:
  The Surface Electromyography (sEMG) class represents a surface EMG signal. It has the following methods:
  Methods:
    simulate_recruitment_model(): Simulates the motor unit recruitment with firing patterns on increasing the number of muscle fibers per motor unit.
    plot_recruitment_model(): Plots the firing patterns of the motor unit recruitment.
    simulate_surface_emg(): Simulates the surface EMG signal generated by the motor unit recruitment.
    plot_surface_emg_array(): Plots the surface EMG signal generated by the summation over the motor unit recruitment.

  The sEMG class also has a number of attributes that can be used to configure the simulation, such as:
  Attributes:
    For simulate_recruitment_model:
      simulation_time: Total simulation time in seconds.
      sampling_rate: Sample rate in Hz.
      ramp: Up-stable-down in seconds.
      maximum_excitation_level: Percentage % of max exc.
      number_of_motor_units: Number of motoneurons in the pool.
      recruitment_range: Range of recruitment threshold values.
      excitatory_gain: Gain of the excitatory drive-firing rate relationship.
      minimum_firing_rate: Minimum firing rate (Hz).
      peak_firing_rate_first_unit: Peak firing rate of the first motoneuron (Hz).
      peak_firing_rate_difference: Desired difference in peak firing rates between the first and last units (Hz):
      inter_spike_interval_coefficient_variation: The inter spike interval variance coefficient.
    
    For simulate_surface_emg:
      twitch_force_range: The range of twitch forces RP (force units).
      motor_unit_density: The motor-unit fibre density (20 unit fibres/mm^2 area of muscle).
      smallest_motor_unit_number_of_fibres: The smallest motor unit innervated 28 fibres.
      largest_motor_unit_number_of_fibres: The largest motor unit innervated 2728 fibres.
      muscle_fibre_diameter: The muscle-fibre diameter (46 µm).
      muscle_cross_sectional_diameter: The muscle cross-sectional diameter (1.5 cm).
      electrodes_in_z: Number of elecrodes in the array, in the direction of the fibre.
      electrodes_in_x: Number of electrodes in the array across the fiber.

    For plotting methods:
      y_limit_minimum: Minimum value of plot y-axis.
      y_limit_maximum: Maximum value of plot y-axis.
...

Save Data class:

  The SaveData (SD) class provides methods for saving and loading data from files. It has the following methods:
  Methods:
    save_output_data(): Saves the data of the any signal to a file.
    open_and_load_saved_data(): Opens the already saved data from a file .npy for usage in Python.
    save_single_fibre_action_potential(): Saves the action potential of a single muscle fibre in the motor unit to a file.
    plot_saved_motor_unit(): Plots the saved file for action potential of the motor unit with 10 electrodes in the z-direction and 5 electrodes in the x-direction using the default number of electrodes as in the saved simulated file.
    plot_saved_surface_emg_array():Plots the saved file for surface EMG array by changing the electrodes in the z-direction to 1 and the electrodes in the x-direction to 1 using the default number of electrodes as in the  saved simulated file.

  The SD class also has a number of attributes that can be used to configure the saving and loading of data, such as:
  Attributes:
    For save_output_data:
      filename: The filename to save the output data to.
      output_data: The output data to be saved.

    For open_and_load_saved_data:
      filename: The name of the file containing the saved .npy data.

    For plotting mothods:
      y_limit_minimum: Minimum value of plot y-axis.
      y_limit_minimum: Maximum value of plot y-axis.
      number_of_electrodes_z: Number of elecrodes in the array, in the direction of the fibre.
      number_of_electrodes_x: Number of electrodes in the array across the fiber.
      time_length:
      delta_time:
      simulation_time: Total simulation time in seconds.
      sampling_rate: Sample rate (10 kHz).
.......................................................................................................................................
Example usage:

from MU import MotorUnit
from sEMG import SurfaceEMG
from SD import SaveData

### Create a MotorUnit object.
motor_unit = MotorUnit()

# Changing values.
#motor_unit.A = 10
#motor_unit.B = -10
#motor_unit.C = 2
#motor_unit.plot_length = 3
#motor_unit.scaling_factor = 3

# Get the amplitude of the tripole current distribution.
amplitudes = motor_unit.get_tripole_amplitude()

# Changing values.
#motor_unit.y_limit_minimum = -2
#motor_unit.y_limit_maximum = 2

# Plot the current distribution and the action potential.
motor_unit.plot_current_distribution_action_potential()

# Get the distance between the tripole current distribution.
distances = motor_unit.get_tripole_distance()

# Change values.
#motor_unit.fibre_length = 1
#motor_unit.conduction_velocity = 1
#motor_unit.ratio_axial_radial_conductivity = 1
#motor_unit.radial_conductivity = 1
#motor_unit.inter_electrode_spacing = 1
#motor_unit.number_of_electrodes_z = 10
#motor_unit.electrode_shift = 1
#motor_unit.initial_neuromuscular_junction = 1
#motor_unit.fibre_depth = 1
#motor_unit.extermination_zone_width = 1
#motor_unit.innervation_zone_width = 1
#motor_unit.time_length = 10

# Simulate the single fibre's action potential.
motor_unit.simulate_fibre_action_potential()

# Plot the the single fibre's action potential.
motor_unit.plot_fibre_action_potential

# Change values.
#motor_unit.motor_unit_radius = 1
#motor_unit.number_of_fibres = 1

# Simulate the motor unit's action potential.
motor_unit.simulate_motor_unit()

# Plot the motor unit's action potential.
motor_unit.plot_motor_unit()

### Create a SurfaceEMG object.
surface_emg = SurfaceEMG()

# Simulate the motor unit recruitment firing pattern.
surface_emg.simulate_recruitment_model()

# Plot the motor unit recruitment firing pattern.
surface_emg.plot_recruitment_model()

# Simulate the surface EMG signal.
surface_emg.simulate_surface_emg()

# Plot the surface EMG signal only for first electrode in the array.
surface_emg.plot_first_electrode_suface_EMG()

# Plot the surface EMG signal for electrode's array.
surface_emg.plot_suface_emg_array()

### Create a SaveData object
save_data = SaveData()

# Save the saved motor unit data to a file.
motot_unit_data = MotorUnit().simulate_motor_unit()
save_data.save_output_data(motot_unit_data, 'simulate_motot_unit')

# Load the saved motor unit data from a file.
motor_unit_data = save_data.open_and_load_saved_data('simulate_motor_unit.npy')

# Plot the saved motor unit data.
save_data.plot_saved_motor_unit(motor_unit_data)

# Save the surface EMG signal to a file.
surface_emg_data = SurfaceEMG().simulate_surface_emg()
save_data.save_output_data(surface_emg_data, 'simulate_surface_emg')

# Load the saved surface EMG signal data to a file.
semg_data = save_data.open_and_load_saved_data('simulate_surface_emg.npy')

# Plot the saved surface EMG signal data.
save_data.plot_saved_surface_emg_array(semg_data)
"""
#  #########################    #########################               ##########################    #######################
                                                          # THE END #
#  #########################    #########################               ##########################    #######################
